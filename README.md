## Лабораторна робота: Обчислення CRC за поліном CRC‑32K (Koopman)

### Умова
- Реалізувати алгоритми обчислення CRC для повідомлення довжиною K = 1000 біт (випадкова послідовність 0/1) за фіксованим утворюючим поліном.
- Поліном за варіантом: CRC‑32K (Koopman)  
  Поліном у степеневому вигляді:  
  x^32 + x^30 + x^29 + x^28 + x^26 + x^20 + x^19 + x^17 + x^16 + x^15 + x^11 + x^10 + x^7 + x^6 + x^4 + x^2 + x + 1  
  У “нормальній” 32‑бітній формі (без старшого члена x^32): `0x741B8CD7`.  
  Віддзеркалена (LSB‑first) форма полінома: `0xEB31D82E`.
 - Провести порівняльний аналіз реалізацій алгоритмів за їх ресурсною складністю. Оцінити середній час обчислення CRC за кожним з алгоритмів для довільно узятої досить великої кількості експериментів.

### Реалізовані алгоритми
- 1) Простий послідовний (MSB‑first, побітовий)
- 2) Табличний (MSB‑first, 256‑елементна таблиця)
- 3) Віддзеркальний послідовний (LSB‑first, побітовий)
- 4) Віддзеркальний табличний (LSB‑first, 256‑елементна таблиця)

Пари алгоритмів усередині одного сімейства збігаються між собою (MSB‑first побітовий = MSB‑first табличний; LSB‑first побітовий = LSB‑first табличний). Значення між сімействами (MSB‑first vs LSB‑first) відрізняються через різну параметризацію потоку бітів (RefIn/RefOut).

### Структура
- `crc32k.py` — реалізації алгоритмів, генерація таблиць і даних, самоперевірка.
- `main.py` — швидкий запуск: генерує 1000 біт і друкує CRC усіма методами.
- `benchmark.py` — порівняльний аналіз часу (багато експериментів).

### Запуск
Вимагає Python 3.9+ (зовнішніх залежностей немає).

```bash
python main.py
```

Запуск бенчмарку (за замовчуванням 10 000 експериментів на повідомлення 1000 біт):
```bash
python benchmark.py --trials 10000 --bits 1000 --seed 12345
```
Параметри:
- `--trials` — кількість експериментів .
- `--bits` — довжина повідомлення в бітах (за умовою 1000; кратність 8 підтримується напряму).
- `--seed` — фіксація ГВЧ для відтворюваності.

Приклад виводу бенчмарку (числа залежать від ПК):
```
Message: 1000 bits (125 bytes), trials: 10000
Algorithm                          avg μs/op     MB/s
bitwise_msb                           2.10      59.5
table_msb                             0.38     328.7
bitwise_reflected                     1.77      70.6
table_reflected                       0.31     403.9
All algorithms agree on CRC: 0xXXXXXXXX
```

### Короткий опис алгоритмів
- **MSB‑first побітовий**: моделює ділення поліномів над GF(2). Для кожного біта: порівнюємо старший біт регістру з вхідним, зсуваємо вліво, за потреби XOR із поліномом `0x741B8CD7`.
- **MSB‑first табличний**: попередньо генерується таблиця на 256 елементів. Обробка по байтах: `index = (crc >> 24) ^ byte`, далі зсув і XOR з таблицею.
- **LSB‑first побітовий (віддзеркальний)**: обробка молодшим бітом уперед, зсув праворуч і XOR з віддзеркаленим поліном `0xEB31D82E`. Для відповідності результат віддзеркалюється наприкінці.
- **LSB‑first табличний (віддзеркальний)**: класична «рефлектна» таблиця на 256 елементів; обробка по байтах: `index = (crc ^ byte) & 0xFF`, далі зсув праворуч і XOR з таблицею; наприкінці результат віддзеркалюється.

Складність:
- Побітові варіанти: O(8·N) операцій для N байтів.
- Табличні варіанти: O(N), в 7–10× швидші завдяки обробці по байтах.

### Примітки щодо відповідності результатів
Щоб усі 4 реалізації давали однаковий 32‑бітний CRC:
- використовуються однакові параметри ініціалізації (початкове значення 0, без фінального XOR),
+- для LSB‑first реалізацій результат додатково віддзеркалюється (RefOut).

### Самоперевірка
```bash
python -c "import crc32k as c; c.self_test(); print('OK')"
```

### Результати запусків і аналіз
Нижче — приклад фактичного виводу бенчмарку на цій машині для 10 000 експериментів, повідомлення 1000 біт (125 байтів):

```
Message: 1000 bits (125 bytes), trials: 10000
Algorithm           avg μs/op      MB/s
bitwise_msb            182.57       0.7
table_msb               20.83       5.7
bitwise_reflected       96.86       1.2
table_reflected         20.35       5.9
bitwise_msb              CRC: 0xB0244F82
table_msb                CRC: 0xB0244F82
bitwise_reflected        CRC: 0x117D92DC
table_reflected          CRC: 0x117D92DC
Mismatch detected among algorithms:
  OK  bitwise_msb: 0xB0244F82 (ref 0xB0244F82)
  OK  table_msb: 0xB0244F82 (ref 0xB0244F82)
  ERR bitwise_reflected: 0x117D92DC (ref 0xB0244F82)
  ERR table_reflected: 0x117D92DC (ref 0xB0244F82)
```

Пояснення:
- **Пари збігаються всередині сімейств**:
  - MSB‑first побітовий = MSB‑first табличний → CRC `0xB0244F82`.
  - LSB‑first побітовий = LSB‑first табличний → CRC `0x117D92DC`.
- **Між сімействами значення відрізняються** через різну параметризацію напрямку бітів (RefIn/RefOut). Обидва результати коректні для CRC‑32K, але описують різні режими використання.
- **Продуктивність**:
  - Табличні реалізації приблизно у ~9× швидші за побітові (наприклад, `20.83 μs` проти `182.57 μs` для MSB‑first).
  - LSB‑first побітовий швидший за MSB‑first побітовий (~1.9× у наведеному вимірюванні), а табличні варіанти обох сімейств мають дуже схожу швидкодію (~5.7–5.9 MB/s).
- Числа залежать від апаратного забезпечення та інтерпретатора Python, однак відносні висновки зберігаються: табличні методи дають суттєвий приріст швидкості при однаковому результаті в межах одного сімейства.


